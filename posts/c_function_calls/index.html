<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.101.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>C function calls (32-bit)&nbsp;&ndash;&nbsp;George&#39;s Blog</title><link rel="stylesheet" href="/georgesims21.github.io/css/core.min.6391195f7c0920b53937f5eed2bfc37b11cb7bd13a9b537ad5c0ff9634c07539facf25b4d549fa7fff38dd1551201e55.css" integrity="sha384-Y5EZX3wJILU5N/Xu0r/DexHLe9E6m1N61cD/ljTAdTn6zyW01Un6f/843RVRIB5V"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="C function calls (32-bit)" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">George's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank" rel="noopener noreferrer">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">100% JavaScript-free</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">C function calls (32-bit)</h1></section><article class="article markdown-body"><p>Each CPU has the following registers (64-bit in parantheses):</p>
<ul>
<li>PC (IP): Instruction pointer  - Points to next instruction for the CPU to execute</li>
<li>SP (SP): Stack pointer        - Points to the top of the stack</li>
<li>FP (BP): Base pointer         - Points to the stack frame of the current active function</li>
<li>RVR (AX): Return value      - Points to the function return value</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">main</span><span class="p">()</span>                  <span class="o">|</span>   <span class="kt">int</span> <span class="n">sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>                       <span class="o">|</span>   <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>            <span class="o">|</span>   <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>    <span class="o">|</span>   <span class="n">u</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">c</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>          <span class="o">|</span>   <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="o">+</span><span class="n">u</span><span class="o">+</span><span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;c=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>    <span class="o">|</span>   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>                       <span class="o">|</span>
</span></span></code></pre></div><p>When a C program is envoked, the return address (current PC) is pushed onto the stack and then the value stored in the PC register is replaced with the function we wish the CPU to execute. In the above case when we wish to run the program (call main()), the current PC is pushed and PC is replaced by the entry address of main(). In this diagram XXXX denotes stack data before we run the program:</p>
<pre tabindex="0"><code>(Stack grows downward)
High address      --&gt;     Low address
-------------------------------------
            | XXXX | PC |
                        ^
                       SP
-------------------------------------
</code></pre><p>Every C program follows the same procedure when called (following main and sub program):</p>
<ol>
<li>Push FP onto the stack to save the CPU&rsquo;s previous stack frame location</li>
</ol>
<pre tabindex="0"><code>            | XXXX | PC | FP |
                             ^
                            SP
</code></pre><ol start="2">
<li>Point FP to the new FP to establish the new stack frame</li>
</ol>
<pre tabindex="0"><code>            | XXXX | PC | FP |
                             ^
                           SP,FP
</code></pre><ol start="3">
<li>Allocate space for auto local variables, but don&rsquo;t initialise them</li>
</ol>
<pre tabindex="0"><code>                               a   b   c
            | XXXX | PC | FP | ? | ? | ? |
                             ^           ^
                            FP          SP
</code></pre><ol start="4">
<li>Potentially allocate more for temporary memory (denoted by tmp)</li>
</ol>
<pre tabindex="0"><code>                               a   b   c
            | XXXX | PC | FP | ? | ? | ? | tmp |
                             ^                 ^
                            FP                SP
</code></pre><ol start="5">
<li>The code starts executing, in our case assigning the values to the variables
(in main) comes first</li>
</ol>
<pre tabindex="0"><code>                               a   b   c
            | XXXX | PC | FP | 1 | 2 | 3 | tmp |
                             ^                 ^
                            FP                SP
</code></pre><p>Using the assumption that we know an int is 4 bytes (i.e sizeof(int) == 4), the
assignments can be done individually by simply measuring the distance between
the FP we saved and the registers next to it, thus -4(FP) == a, -8(FP) == b and
-12(FP) == c. In assembly code this would look like:</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">movl $1, -4(%ebp) /* move value 1 ($1) into register located -4(FP)*/
movl $2, -8(%ebp)
movl $3, -12(%ebp)
</code></pre><ol start="6">
<li>In our case, main() calls sub() via a direct assignment to the variable c.
First the parameters given to the sub() method are pushed in reverse order, so b
and then a. We then repeat the same steps (because this is a C program) from 1.
to make the CPU execute the sub() function. So it would look something like this afterwards:</li>
</ol>
<pre tabindex="0"><code>        Stack frame of                    Stack frame of
|---------- main() ----------|     |--------- sub() ---------|
                   a   b   c         b   a             u   v
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 | PC | FP | 4 | 5 | tmp |
                 ^                                   ^             ^
                 |                                  FP            SP
                 +------------ points to ------------+
</code></pre><p>You can also see from this diagram that accessing the parameters given to a
function is positively relative to the FP rather than negative: 8(FP) == a and
12(FP) == b. This format is exactly how a stack looks to the calling function,
or more generally:</p>
<pre tabindex="0"><code>| -------------------- Function&#39;s stack frame ----------------------|
| params | return PC (CPU should return to) | saved FP | local vars |
</code></pre><p>A simple program like this:</p>
<pre tabindex="0"><code>crt0.o -&gt; main() -&gt; A(par_a) -&gt; B(par_b) -&gt; C(par_c)
</code></pre><p>Should look like this when thinking of stack frames:</p>
<pre tabindex="0"><code>                   SF of        SF of
         ...    |- main() -|  |- A() -| ...
| 0 |
    ^ 
    +--| FP0 |
             ^
             +--| FPmain() |
                           ^
                           +--| FPA() |
                                      ^
                                      +--| FPB() |
                                                 ^
                                                 +--| FPC() |
                                                            ^
                                                       CPU.FP
</code></pre><ol start="7">
<li>The return value of sub() is placed into the AX register and the
function returns to the callers stack frame. Before returning however, the local
variables must be deallocated:</li>
</ol>
<ul>
<li>First copy the value of the current FP into SP, so they are pointing to the
same thing</li>
</ul>
<pre tabindex="0"><code>                   a   b   c         b   a 
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 | PC | FP | 
                                                     ^
                                                 FP,SP
</code></pre><ul>
<li>Next pop the stack into the FP pointer, giving it the FP of the caller</li>
</ul>
<pre tabindex="0"><code>                   a   b   c         b   a 
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 | PC |
                 ^                              ^
                FP                             SP,(CPU.PC)
</code></pre><ul>
<li>Finally the RET function is executed, popping the top of the stack into the PC
register, making the CPU execute from the saved return address, belonging to
the caller</li>
</ul>
<pre tabindex="0"><code>                   a   b   c         b   a 
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 |
            ^    ^                         ^
     (CPU.PC)   FP                        SP
</code></pre><ol start="8">
<li>Lastly, the caller &lsquo;catches&rsquo; the value in the AX register, and cleans the
remaining parameters from the called function by simply adding 8 to the SP
(2* sizeof(int)) and moves on to the next instruction after main. The figure
below shows that we are back to being inside the stack frame of main() only</li>
</ol>
<pre tabindex="0"><code>           Stack frame of
| ------------ main() -------------|
                   a   b   c
| XXXX | PC | FP | 1 | 2 | 3 | tmp |
            ^    ^                 ^
     (CPU.PC)   FP                SP
</code></pre><h3 id="side-note-long-jump">Side note: long jump</h3>
<p>A long jump can be used to esentially skip returning to the caller, and return
elsewhere, normally earlier than the caller. If we have a program in which:
main() -&gt; A() -&gt; B(), but upon return B() jumps to main() instead of its caller A().</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/** longjump.c file: demonstrate long jump in Linux **/</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;setjmp.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">jmp_buf</span> <span class="n">env</span><span class="p">;</span> <span class="c1">// for saving longjmp environment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;call setjmp to save environment</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">r</span><span class="o">=</span><span class="n">setjmp</span><span class="p">(</span><span class="n">env</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// saves cur exec env in jmp_buf strct
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">A</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;normal return</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;back to main() via long jump, r=%d a=%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">A</span><span class="p">()</span> <span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;enter A()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">B</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;exit A()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">B</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;enter B()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;long jump? (y|n) &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">getchar</span><span class="p">()</span><span class="o">==</span><span class="sc">&#39;y&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">longjmp</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="mi">1234</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;exit B()</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The idea is that the registers containing the callers PC and FP are replaced
by the values stored in the jmp_buf struct, which in the above example are
main()&rsquo;s, which means we can follow the regular steps and we will skip A()
completely. It is also possible for the longjmp() function to save the CPU&rsquo;s
current registers and SP so that it can be restored if needed.</p>
<pre tabindex="0"><code>                   Replace with saved
                          |
| XXXX | PC | FP | ... |  =&gt;  | XXXX | SavedPC | SavedFP | ... |
                 ^     ^                                 ^     ^
                FP    SP                                FP    SP
</code></pre></article><section class="article labels"><a class="category" href=/categories/theory/>Theory</a><a class="tag" href=/tags/c/>C</a><a class="tag" href=/tags/systems-programming/>Systems Programming</a><a class="tag" href=/tags/assembly/>Assembly</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/georgesims21.github.io/posts/64-bit-gcc_runtime_stack_usage/"><span class="iconfont icon-article"></span>64-bit-GCC Runtime Stack Usage</a></p><p><a class="link" href="/georgesims21.github.io/posts/fuse/"><span class="iconfont icon-article"></span>FUSE</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 Notepadium.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a>
<a href='https://ipv6-test.com/validate.php?url=referer'
  ><img src='https://ipv6-test.com/button-ipv6-80x15.png' 
        alt='ipv6 ready' title='ipv6 ready' border='0' 
/></a>
</p></div>
</section></body>

</html>