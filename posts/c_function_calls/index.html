<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>C function calls (32-bit) - George's Blog</title><meta name=Description content="Welcome to George's Blog"><meta property="og:title" content="C function calls (32-bit)"><meta property="og:description" content="Each CPU has the following registers (64-bit in parantheses):
PC (IP): Instruction pointer - Points to next instruction for the CPU to execute SP (SP): Stack pointer - Points to the top of the stack FP (BP): Base pointer - Points to the stack frame of the current active function RVR (AX): Return value - Points to the function return value main() | int sub(int x, int y) { | { int a, b, c; | int u, v; a = 1; b = 2; c = 3; | u = 4; v = 5; c = sub(a, b); | return x+y+u+v; printf(&#34;c=%d\n&#34;, c); | } } | When a C program is envoked, the return address (current PC) is pushed onto the stack and then the value stored in the PC register is replaced with the function we wish the CPU to execute."><meta property="og:type" content="article"><meta property="og:url" content="georgesims21.github.io/posts/c_function_calls/"><meta property="og:image" content="/logo.png"><meta property="article:section" content="posts"><meta property="og:site_name" content="George's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo.png"><meta name=twitter:title content="C function calls (32-bit)"><meta name=twitter:description content="Each CPU has the following registers (64-bit in parantheses):
PC (IP): Instruction pointer - Points to next instruction for the CPU to execute SP (SP): Stack pointer - Points to the top of the stack FP (BP): Base pointer - Points to the stack frame of the current active function RVR (AX): Return value - Points to the function return value main() | int sub(int x, int y) { | { int a, b, c; | int u, v; a = 1; b = 2; c = 3; | u = 4; v = 5; c = sub(a, b); | return x+y+u+v; printf(&#34;c=%d\n&#34;, c); | } } | When a C program is envoked, the return address (current PC) is pushed onto the stack and then the value stored in the PC register is replaced with the function we wish the CPU to execute."><meta name=application-name content="George's Blog"><meta name=apple-mobile-web-app-title content="George's Blog"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=georgesims21.github.io/posts/c_function_calls/><link rel=prev href=georgesims21.github.io/posts/fuse/><link rel=next href=georgesims21.github.io/posts/64-bit-gcc_runtime_stack_usage/><link rel=stylesheet href=/georgesims21.github.io/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C function calls (32-bit)","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"georgesims21.github.io\/posts\/c_function_calls\/"},"genre":"posts","keywords":"C, Systems Programming, Assembly","wordcount":1176,"url":"georgesims21.github.io\/posts\/c_function_calls\/","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"George Sims"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=georgesims21.github.io/ title="George's Blog"><span id=id-1 class=typeit></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/georgesims21.github.io/posts/ title=Posts>Posts </a><a class=menu-item href=/georgesims21.github.io/tags/>Tags </a><a class=menu-item href=/georgesims21.github.io/categories/>Categories </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=georgesims21.github.io/ title="George's Blog"><span id=id-2 class=typeit></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/georgesims21.github.io/posts/ title=Posts>Posts</a><a class=menu-item href=/georgesims21.github.io/tags/ title>Tags</a><a class=menu-item href=/georgesims21.github.io/categories/ title>Categories</a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">C function calls (32-bit)</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/georgesims21 title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>George Sims</a></span>&nbsp;<span class=post-category>included in <a href=georgesims21.github.io/categories/theory/><i class="far fa-folder fa-fw" aria-hidden=true></i>Theory</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=0001-01-01>0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1176 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;6 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#side-note-long-jump>Side note: long jump</a></li></ul></li></ul></nav></div></div><div class=content id=content><p>Each CPU has the following registers (64-bit in parantheses):</p><ul><li>PC (IP): Instruction pointer - Points to next instruction for the CPU to execute</li><li>SP (SP): Stack pointer - Points to the top of the stack</li><li>FP (BP): Base pointer - Points to the stack frame of the current active function</li><li>RVR (AX): Return value - Points to the function return value</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>main()                  <span style=color:#f92672>|</span>   <span style=color:#66d9ef>int</span> sub(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y)
</span></span><span style=display:flex><span>{                       <span style=color:#f92672>|</span>   {
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> a, b, c;            <span style=color:#f92672>|</span>   <span style=color:#66d9ef>int</span> u, v;
</span></span><span style=display:flex><span>a <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; b <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; c <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;    <span style=color:#f92672>|</span>   u <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; v <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> sub(a, b);          <span style=color:#f92672>|</span>   <span style=color:#66d9ef>return</span> x<span style=color:#f92672>+</span>y<span style=color:#f92672>+</span>u<span style=color:#f92672>+</span>v;
</span></span><span style=display:flex><span>printf(<span style=color:#e6db74>&#34;c=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, c);    <span style=color:#f92672>|</span>   }
</span></span><span style=display:flex><span>}                       <span style=color:#f92672>|</span>
</span></span></code></pre></div><p>When a C program is envoked, the return address (current PC) is pushed onto the stack and then the value stored in the PC register is replaced with the function we wish the CPU to execute. In the above case when we wish to run the program (call main()), the current PC is pushed and PC is replaced by the entry address of main(). In this diagram XXXX denotes stack data before we run the program:</p><pre tabindex=0><code>(Stack grows downward)
High address      --&gt;     Low address
-------------------------------------
            | XXXX | PC |
                        ^
                       SP
-------------------------------------
</code></pre><p>Every C program follows the same procedure when called (following main and sub program):</p><ol><li>Push FP onto the stack to save the CPU&rsquo;s previous stack frame location</li></ol><pre tabindex=0><code>            | XXXX | PC | FP |
                             ^
                            SP
</code></pre><ol start=2><li>Point FP to the new FP to establish the new stack frame</li></ol><pre tabindex=0><code>            | XXXX | PC | FP |
                             ^
                           SP,FP
</code></pre><ol start=3><li>Allocate space for auto local variables, but don&rsquo;t initialise them</li></ol><pre tabindex=0><code>                               a   b   c
            | XXXX | PC | FP | ? | ? | ? |
                             ^           ^
                            FP          SP
</code></pre><ol start=4><li>Potentially allocate more for temporary memory (denoted by tmp)</li></ol><pre tabindex=0><code>                               a   b   c
            | XXXX | PC | FP | ? | ? | ? | tmp |
                             ^                 ^
                            FP                SP
</code></pre><ol start=5><li>The code starts executing, in our case assigning the values to the variables
(in main) comes first</li></ol><pre tabindex=0><code>                               a   b   c
            | XXXX | PC | FP | 1 | 2 | 3 | tmp |
                             ^                 ^
                            FP                SP
</code></pre><p>Using the assumption that we know an int is 4 bytes (i.e sizeof(int) == 4), the
assignments can be done individually by simply measuring the distance between
the FP we saved and the registers next to it, thus -4(FP) == a, -8(FP) == b and
-12(FP) == c. In assembly code this would look like:</p><pre tabindex=0><code class=language-assembly data-lang=assembly>movl $1, -4(%ebp) /* move value 1 ($1) into register located -4(FP)*/
movl $2, -8(%ebp)
movl $3, -12(%ebp)
</code></pre><ol start=6><li>In our case, main() calls sub() via a direct assignment to the variable c.
First the parameters given to the sub() method are pushed in reverse order, so b
and then a. We then repeat the same steps (because this is a C program) from 1.
to make the CPU execute the sub() function. So it would look something like this afterwards:</li></ol><pre tabindex=0><code>        Stack frame of                    Stack frame of
|---------- main() ----------|     |--------- sub() ---------|
                   a   b   c         b   a             u   v
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 | PC | FP | 4 | 5 | tmp |
                 ^                                   ^             ^
                 |                                  FP            SP
                 +------------ points to ------------+
</code></pre><p>You can also see from this diagram that accessing the parameters given to a
function is positively relative to the FP rather than negative: 8(FP) == a and
12(FP) == b. This format is exactly how a stack looks to the calling function,
or more generally:</p><pre tabindex=0><code>| -------------------- Function&#39;s stack frame ----------------------|
| params | return PC (CPU should return to) | saved FP | local vars |
</code></pre><p>A simple program like this:</p><pre tabindex=0><code>crt0.o -&gt; main() -&gt; A(par_a) -&gt; B(par_b) -&gt; C(par_c)
</code></pre><p>Should look like this when thinking of stack frames:</p><pre tabindex=0><code>                   SF of        SF of
         ...    |- main() -|  |- A() -| ...
| 0 |
    ^ 
    +--| FP0 |
             ^
             +--| FPmain() |
                           ^
                           +--| FPA() |
                                      ^
                                      +--| FPB() |
                                                 ^
                                                 +--| FPC() |
                                                            ^
                                                       CPU.FP
</code></pre><ol start=7><li>The return value of sub() is placed into the AX register and the
function returns to the callers stack frame. Before returning however, the local
variables must be deallocated:</li></ol><ul><li>First copy the value of the current FP into SP, so they are pointing to the
same thing</li></ul><pre tabindex=0><code>                   a   b   c         b   a 
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 | PC | FP | 
                                                     ^
                                                 FP,SP
</code></pre><ul><li>Next pop the stack into the FP pointer, giving it the FP of the caller</li></ul><pre tabindex=0><code>                   a   b   c         b   a 
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 | PC |
                 ^                              ^
                FP                             SP,(CPU.PC)
</code></pre><ul><li>Finally the RET function is executed, popping the top of the stack into the PC
register, making the CPU execute from the saved return address, belonging to
the caller</li></ul><pre tabindex=0><code>                   a   b   c         b   a 
| XXXX | PC | FP | 1 | 2 | 3 | tmp | 2 | 1 |
            ^    ^                         ^
     (CPU.PC)   FP                        SP
</code></pre><ol start=8><li>Lastly, the caller &lsquo;catches&rsquo; the value in the AX register, and cleans the
remaining parameters from the called function by simply adding 8 to the SP
(2* sizeof(int)) and moves on to the next instruction after main. The figure
below shows that we are back to being inside the stack frame of main() only</li></ol><pre tabindex=0><code>           Stack frame of
| ------------ main() -------------|
                   a   b   c
| XXXX | PC | FP | 1 | 2 | 3 | tmp |
            ^    ^                 ^
     (CPU.PC)   FP                SP
</code></pre><h3 id=side-note-long-jump>Side note: long jump</h3><p>A long jump can be used to esentially skip returning to the caller, and return
elsewhere, normally earlier than the caller. If we have a program in which:
main() -> A() -> B(), but upon return B() jumps to main() instead of its caller A().</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/** longjump.c file: demonstrate long jump in Linux **/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;setjmp.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>jmp_buf env; <span style=color:#75715e>// for saving longjmp environment
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> r, a<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;call setjmp to save environment</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((r<span style=color:#f92672>=</span>setjmp(env)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>){ <span style=color:#75715e>// saves cur exec env in jmp_buf strct
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        A();
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;normal return</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;back to main() via long jump, r=%d a=%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, r, a);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>A</span>() { 
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;enter A()</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    B();
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;exit A()</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>B</span>() {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;enter B()</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;long jump? (y|n) &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (getchar()<span style=color:#f92672>==</span><span style=color:#e6db74>&#39;y&#39;</span>)
</span></span><span style=display:flex><span>        longjmp(env, <span style=color:#ae81ff>1234</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;exit B()</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The idea is that the registers containing the callers PC and FP are replaced
by the values stored in the jmp_buf struct, which in the above example are
main()&rsquo;s, which means we can follow the regular steps and we will skip A()
completely. It is also possible for the longjmp() function to save the CPU&rsquo;s
current registers and SP so that it can be restored if needed.</p><pre tabindex=0><code>                   Replace with saved
                          |
| XXXX | PC | FP | ... |  =&gt;  | XXXX | SavedPC | SavedFP | ... |
                 ^     ^                                 ^     ^
                FP    SP                                FP    SP
</code></pre></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 0001-01-01</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=georgesims21.github.io/posts/c_function_calls/ data-title="C function calls (32-bit)" data-hashtags="C,Systems Programming,Assembly"><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=georgesims21.github.io/posts/c_function_calls/ data-hashtag=C><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=georgesims21.github.io/posts/c_function_calls/ data-title="C function calls (32-bit)"><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=georgesims21.github.io/posts/c_function_calls/ data-title="C function calls (32-bit)"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@7.0.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=georgesims21.github.io/posts/c_function_calls/ data-title="C function calls (32-bit)"><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=georgesims21.github.io/tags/c/>C</a>,&nbsp;<a href=georgesims21.github.io/tags/systems-programming/>Systems Programming</a>,&nbsp;<a href=georgesims21.github.io/tags/assembly/>Assembly</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=georgesims21.github.io/>Home</a></span></section></div><div class=post-nav><a href=georgesims21.github.io/posts/fuse/ class=prev rel=prev title=FUSE><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>FUSE</a>
<a href=georgesims21.github.io/posts/64-bit-gcc_runtime_stack_usage/ class=next rel=next title="64-bit-GCC Runtime Stack Usage">64-bit-GCC Runtime Stack Usage<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.101.0">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://github.com/georgesims21 target=_blank>George Sims</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"id-1":"George's Blog","id-2":"George's Blog"},search:{highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:100}}</script><script type=text/javascript src=/georgesims21.github.io/js/theme.min.js></script></body></html>